import React from 'react'
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import AIInputSearch from '@/components/ai-input-search'
import { GeminiMessage } from '@/components/gemini-message'
import type { ChatMessage } from '@/hooks/use-chat'

// Mock framer-motion
vi.mock('motion/react', () => ({
  motion: {
    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,
    span: ({ children, ...props }: any) => <span {...props}>{children}</span>,
    img: ({ children, ...props }: any) => <img {...props}>{children}</img>,
  },
  AnimatePresence: ({ children }: any) => <>{children}</>,
}))

// Mock the auto-resize textarea hook
vi.mock('@/hooks/use-auto-resize-textarea', () => ({
  useAutoResizeTextarea: () => ({
    textareaRef: { current: null },
    adjustHeight: vi.fn(),
  }),
}))

// Mock the image display component
vi.mock('@/components/image-display', () => ({
  ImageDisplay: ({ src, alt, caption, isLoading, error, onRetry }: any) => (
    <div data-testid="image-display">
      <img src={src} alt={alt} />
      {caption && <div data-testid="image-caption">{caption}</div>}
      {isLoading && <div data-testid="image-loading">Loading...</div>}
      {error && (
        <div data-testid="image-error">
          {error}
          {onRetry && <button onClick={onRetry} data-testid="retry-button">Retry</button>}
        </div>
      )}
    </div>
  ),
  ImageLoadingSkeleton: () => <div data-testid="image-skeleton">Loading skeleton</div>,
}))

// Mock the thinking indicator
vi.mock('@/components/thinking-indicator', () => ({
  default: () => <div data-testid="thinking-indicator">Thinking...</div>,
}))

describe('Image Generation Integration', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('End-to-End Image Generation Flow', () => {
    it('handles complete image generation workflow', async () => {
      const onSubmit = vi.fn()
      
      // Render input component
      render(<AIInputSearch onSubmit={onSubmit} />)
      
      // Enable image generation mode
      const imageButton = screen.getByRole('button', { name: /image/i })
      fireEvent.click(imageButton)
      
      // Verify UI changes
      const textarea = screen.getByRole('textbox')
      expect(textarea).toHaveAttribute('placeholder', 'Describe the image you want to generate...')
      expect(imageButton).toHaveClass('bg-purple-500/15')
      
      // Enter image prompt
      fireEvent.change(textarea, { target: { value: 'A majestic mountain landscape at sunset' } })
      
      // Submit request
      const submitButton = screen.getByRole('button', { name: /send/i })
      fireEvent.click(submitButton)
      
      // Verify submission
      expect(onSubmit).toHaveBeenCalledWith('A majestic mountain landscape at sunset', 'image')
      expect(textarea).toHaveValue('') // Input should be cleared
    })

    it('displays loading state during image generation', () => {
      const loadingMessage: ChatMessage = {
        id: 'loading-1',
        content: '',
        type: 'gemini-image',
        timestamp: new Date(),
        metadata: {
          isStreaming: true,
        },
      }

      render(<GeminiMessage message={loadingMessage} />)

      // Should show loading skeleton
      expect(screen.getByTestId('image-skeleton')).toBeInTheDocument()
      expect(screen.getByText('Generating image...')).toBeInTheDocument()
      expect(screen.getByText('Generating image...')).toHaveClass('text-purple-500')
    })

    it('displays successful image generation result', () => {
      const successMessage: ChatMessage = {
        id: 'success-1',
        content: 'A majestic mountain landscape at sunset with golden light',
        type: 'gemini-image',
        timestamp: new Date(),
        metadata: {
          imageUrl: 'https://example.com/generated-mountain.jpg',
          model: 'gemini-1.5-pro-vision',
        },
      }

      render(<GeminiMessage message={successMessage} />)

      // Should show image display
      const imageDisplay = screen.getByTestId('image-display')
      expect(imageDisplay).toBeInTheDocument()

      // Should show image with correct attributes
      const image = screen.getByRole('img')
      expect(image).toHaveAttribute('src', 'https://example.com/generated-mountain.jpg')
      expect(image).toHaveAttribute('alt', 'Generated by Gemini Vision')

      // Should show caption
      const caption = screen.getByTestId('image-caption')
      expect(caption).toHaveTextContent('A majestic mountain landscape at sunset with golden light')

      // Should show correct header
      expect(screen.getByText('Gemini Vision')).toBeInTheDocument()
      expect(screen.getByText('gemini-1.5-pro-vision')).toBeInTheDocument()
    })

    it('handles image generation errors gracefully', () => {
      const errorMessage: ChatMessage = {
        id: 'error-1',
        content: 'Failed to generate image due to content policy',
        type: 'gemini-image',
        timestamp: new Date(),
        metadata: {
          error: 'Content policy violation',
        },
      }

      render(<GeminiMessage message={errorMessage} />)

      // Should show error text
      const errorTexts = screen.getAllByText('Failed to generate image due to content policy')
      expect(errorTexts.length).toBeGreaterThan(0)
      expect(screen.queryByTestId('image-display')).not.toBeInTheDocument()
    })

    it('supports retry functionality for failed image generation', () => {
      const onRetry = vi.fn()
      
      // Mock a message with retry capability
      const retryableMessage: ChatMessage = {
        id: 'retry-1',
        content: 'Network error occurred',
        type: 'gemini-image',
        timestamp: new Date(),
        metadata: {
          imageUrl: 'https://example.com/failed-image.jpg',
        },
      }

      // Render with error state
      render(
        <div data-testid="image-display">
          <div data-testid="image-error">
            Network error occurred
            <button onClick={onRetry} data-testid="retry-button">Retry</button>
          </div>
        </div>
      )

      const retryButton = screen.getByTestId('retry-button')
      fireEvent.click(retryButton)

      expect(onRetry).toHaveBeenCalledOnce()
    })
  })

  describe('UI State Management', () => {
    it('prevents submission during image generation', () => {
      const onSubmit = vi.fn()
      
      render(<AIInputSearch onSubmit={onSubmit} isGenerating={true} />)
      
      const textarea = screen.getByRole('textbox')
      const submitButton = screen.getByRole('button', { name: /send/i })
      
      // Components should be disabled
      expect(textarea).toBeDisabled()
      expect(submitButton).toBeDisabled()
      expect(textarea).toHaveAttribute('placeholder', 'AI is generating...')
      
      // Try to submit
      fireEvent.change(textarea, { target: { value: 'test' } })
      fireEvent.click(submitButton)
      
      expect(onSubmit).not.toHaveBeenCalled()
    })

    it('toggles between text and image modes correctly', () => {
      render(<AIInputSearch />)
      
      const searchButton = screen.getByRole('button', { name: /search/i })
      const imageButton = screen.getByRole('button', { name: /image/i })
      const textarea = screen.getByRole('textbox')
      
      // Initially both should be inactive
      expect(searchButton).not.toHaveClass('bg-sky-500/15')
      expect(imageButton).not.toHaveClass('bg-purple-500/15')
      
      // Activate image mode
      fireEvent.click(imageButton)
      expect(imageButton).toHaveClass('bg-purple-500/15')
      expect(searchButton).not.toHaveClass('bg-sky-500/15')
      expect(textarea).toHaveAttribute('placeholder', 'Describe the image you want to generate...')
      
      // Switch to search mode
      fireEvent.click(searchButton)
      expect(searchButton).toHaveClass('bg-sky-500/15')
      expect(imageButton).not.toHaveClass('bg-purple-500/15')
      expect(textarea).toHaveAttribute('placeholder', 'Search the web...')
    })

    it('maintains input focus during mode switches', () => {
      render(<AIInputSearch />)
      
      const textarea = screen.getByRole('textbox')
      const imageButton = screen.getByRole('button', { name: /image/i })
      
      // Focus textarea
      textarea.focus()
      expect(document.activeElement).toBe(textarea)
      
      // Switch modes
      fireEvent.click(imageButton)
      
      // Focus should be maintained (in a real scenario)
      // Note: jsdom doesn't fully simulate focus behavior, but we can test the intent
      expect(textarea).toBeInTheDocument()
    })
  })

  describe('Accessibility', () => {
    it('provides proper ARIA labels for image generation controls', () => {
      render(<AIInputSearch />)
      
      const imageButton = screen.getByRole('button', { name: /image/i })
      expect(imageButton).toBeInTheDocument()
      
      // The button should be accessible
      expect(imageButton).toHaveAttribute('type', 'button')
    })

    it('provides proper alt text for generated images', () => {
      const imageMessage: ChatMessage = {
        id: 'img-1',
        content: 'A beautiful sunset',
        type: 'gemini-image',
        timestamp: new Date(),
        metadata: {
          imageUrl: 'https://example.com/sunset.jpg',
        },
      }

      render(<GeminiMessage message={imageMessage} />)

      const image = screen.getByRole('img')
      expect(image).toHaveAttribute('alt', 'Generated by Gemini Vision')
    })

    it('supports keyboard navigation for image controls', () => {
      render(<AIInputSearch />)
      
      const imageButton = screen.getByRole('button', { name: /image/i })
      const textarea = screen.getByRole('textbox')
      
      // Should be focusable
      imageButton.focus()
      expect(document.activeElement).toBe(imageButton)
      
      // Should respond to Enter key
      fireEvent.keyDown(imageButton, { key: 'Enter' })
      expect(imageButton).toHaveClass('bg-purple-500/15')
      
      // Textarea should be focusable
      textarea.focus()
      expect(document.activeElement).toBe(textarea)
    })
  })

  describe('Performance Considerations', () => {
    it('handles rapid mode switching without issues', () => {
      render(<AIInputSearch />)
      
      const searchButton = screen.getByRole('button', { name: /search/i })
      const imageButton = screen.getByRole('button', { name: /image/i })
      
      // Rapidly switch modes
      for (let i = 0; i < 10; i++) {
        fireEvent.click(i % 2 === 0 ? imageButton : searchButton)
      }
      
      // Should end up in search mode (last click)
      expect(searchButton).toHaveClass('bg-sky-500/15')
      expect(imageButton).not.toHaveClass('bg-purple-500/15')
    })

    it('cleans up properly when component unmounts', () => {
      const { unmount } = render(<AIInputSearch />)
      
      // Should unmount without errors
      expect(() => unmount()).not.toThrow()
    })
  })
})